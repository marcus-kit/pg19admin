# Code Style — Nuxt 4 + Vue 3.5

Правила оформления кода. Минимализм, читаемость, никакого мусора.

---

## Именование файлов

```
Компоненты     PascalCase.vue       UserCard.vue, BaseButton.vue
Composables    useCamelCase.ts      useAuth.ts, useFetchUsers.ts
Утилиты        camelCase.ts         formatDate.ts, validateEmail.ts
Типы           camelCase.ts         user.ts, database.ts
```

**Правила:**
- Компоненты — минимум 2 слова (избегаем конфликтов с HTML тегами типа `<button>`)
- Префиксы компонентов:
  - `Base` — базовые UI элементы (BaseButton, BaseInput)
  - `The` — единственные на странице (TheHeader, TheSidebar)
  - `App` — уровень приложения (AppLogo, AppFooter)
- Composables — всегда начинаются с `use`

---

## Структура .vue файла

```vue
<script setup lang="ts">
// ─────────────────────────────────────────────────────────────
// 1. TYPE IMPORTS (Импорты типов)
// Типы — это описания данных для TypeScript. Удаляются при сборке.
// ─────────────────────────────────────────────────────────────
import type { User } from '~/types'

// ─────────────────────────────────────────────────────────────
// 2. COMPILER MACROS (Макросы компиляции)
// Специальные функции Nuxt, которые работают при сборке проекта.
// definePageMeta — настройки страницы (защита, layout и т.д.)
// ─────────────────────────────────────────────────────────────
definePageMeta({
  middleware: 'auth', // Защита страницы — только для авторизованных
})

// ─────────────────────────────────────────────────────────────
// 3. PROPS (Входные параметры)
// Данные, которые родительский компонент передаёт этому.
// Пример: <UserCard :user-id="123" /> — здесь userId это prop.
// ─────────────────────────────────────────────────────────────
const props = defineProps<{
  userId: string // ID пользователя для загрузки
}>()

// ─────────────────────────────────────────────────────────────
// 4. EMITS (Исходящие события)
// Способ сообщить родителю что что-то произошло.
// Пример: emit('update', user) — отправляем событие наверх.
// ─────────────────────────────────────────────────────────────
const emit = defineEmits<{
  update: [user: User] // Событие обновления с данными пользователя
}>()

// ─────────────────────────────────────────────────────────────
// 5. COMPOSABLES (Переиспользуемая логика)
// Готовые функции с состоянием. Начинаются с use.
// useRoute — информация о текущей странице (путь, параметры).
// ─────────────────────────────────────────────────────────────
const route = useRoute() // Текущий маршрут

// ─────────────────────────────────────────────────────────────
// 6. REACTIVE STATE (Реактивное состояние)
// Данные, при изменении которых страница автоматически обновится.
// ref() — для простых значений (число, строка, boolean).
// reactive() — для объектов с несколькими полями.
// ─────────────────────────────────────────────────────────────
const isModalOpen = ref(false) // Открыто ли модальное окно
const searchQuery = ref('') // Текст поиска

// ─────────────────────────────────────────────────────────────
// 7. COMPUTED (Вычисляемые свойства)
// Значения, которые автоматически пересчитываются при изменении зависимостей.
// Результат кешируется — не пересчитывается без необходимости.
// ─────────────────────────────────────────────────────────────
const hasSearchQuery = computed(() => searchQuery.value.length > 0) // Есть ли текст поиска

// ─────────────────────────────────────────────────────────────
// 8. FUNCTIONS (Функции / Методы)
// Обычные функции для обработки действий пользователя.
// ─────────────────────────────────────────────────────────────
function openModal() {
  isModalOpen.value = true // Открываем модальное окно
}

function handleSearch() {
  // Обработка поиска
  console.log('Ищем:', searchQuery.value)
}

// ─────────────────────────────────────────────────────────────
// 9. WATCHERS (Наблюдатели)
// Выполняют код когда отслеживаемое значение изменилось.
// Используй для: запросов к API, сохранения в localStorage.
// ─────────────────────────────────────────────────────────────
watch(searchQuery, (newValue) => {
  console.log('Поиск изменился:', newValue) // Реагируем на изменение
})

// ─────────────────────────────────────────────────────────────
// 10. LIFECYCLE HOOKS (Хуки жизненного цикла)
// Функции, которые вызываются на разных этапах жизни компонента.
// onMounted — компонент появился на странице (DOM готов).
// onUnmounted — компонент удаляется (очистка подписок).
// ─────────────────────────────────────────────────────────────
onMounted(() => {
  console.log('Компонент загружен') // Выполнится один раз при загрузке
})
</script>

<template>
  <!-- TEMPLATE (Шаблон) — разметка того, что видит пользователь -->
  <div>
    <h1>Привет</h1>
  </div>
</template>

<style scoped>
/* STYLE (Стили) — CSS оформление. scoped = только для этого компонента */
</style>
```

---

## Порядок атрибутов в template (шаблоне)

```vue
<Component
  v-if="show"        // 1. Условие показа (показать/скрыть)
  v-for="item in items" // 2. Цикл (повторить для каждого)
  :key="item.id"     // 3. Уникальный ключ (обязателен с v-for)
  ref="el"           // 4. Ссылка на элемент (для доступа из кода)
  v-model="value"    // 5. Двусторонняя привязка (ввод ↔ данные)
  :prop="data"       // 6. Передача данных вниз (props)
  @event="handler"   // 7. Обработка событий (клик, ввод и т.д.)
  class="style"      // 8. CSS классы
/>
```

**Запомни порядок:** `v-if → v-for → :key → ref → v-model → :props → @events → class`

---

## Форматирование (настройки ESLint)

```
Отступы          2 пробела (не табы)
Кавычки          одинарные 'строка' (не двойные)
Точка с запятой  не ставим
Запятая в конце  ставим { a: 1, b: 2, }
Длина строки     максимум 100 символов
```

---

## Best Practices — Чистый код

### Пиши коротко и понятно

```typescript
// ❌ Плохо — слишком многословно
const isUserActive = computed(() => {
  if (user.value.status === 'active') {
    return true
  } else {
    return false
  }
})

// ✅ Хорошо — одна строка, тот же смысл
const isUserActive = computed(() => user.value.status === 'active')
```

### Называй так, чтобы было понятно без комментария

```typescript
// ❌ Плохо — непонятно что это
const d = users.filter(u => u.s === 'a')

// ✅ Хорошо — сразу ясно
const activeUsers = users.filter(user => user.status === 'active')
```

### Выходи из функции рано (guard clauses)

```typescript
// ❌ Плохо — много вложенности, трудно читать
function processUser(user) {
  if (user) {
    if (user.isActive) {
      if (user.hasPermission) {
        // основная логика глубоко внутри
      }
    }
  }
}

// ✅ Хорошо — проверки в начале, логика внизу
function processUser(user) {
  if (!user) return // Нет пользователя — выходим
  if (!user.isActive) return // Неактивен — выходим
  if (!user.hasPermission) return // Нет прав — выходим

  // Основная логика — легко читать
}
```

### Используй деструктуризацию

```typescript
// ❌ Плохо — повторяем props.user много раз
const userName = props.user.name
const userEmail = props.user.email
const userRole = props.user.role

// ✅ Хорошо — вытаскиваем всё сразу
const { name, email, role } = props.user
```

### Удаляй мёртвый код

```typescript
// ❌ Плохо — закомментированный код засоряет файл
// function oldImplementation() { ... }
// const unusedVariable = 'test'

// ✅ Хорошо — Git помнит историю, удаляй смело
```

### Один файл — одна задача

```typescript
// ❌ Плохо — всё свалено в один файл
// utils/helpers.ts — 500 строк всего подряд

// ✅ Хорошо — каждая функция в своём файле
// utils/formatDate.ts — форматирование даты
// utils/validateEmail.ts — проверка email
// utils/parseQuery.ts — парсинг URL параметров
```

---

## Комментарии

### Всегда комментируй на русском

```typescript
const users = ref<User[]>([]) // Список пользователей
const isLoading = ref(false) // Идёт ли загрузка
const error = ref<string | null>(null) // Текст ошибки (если есть)

// Загружаем пользователей с сервера
async function fetchUsers() {
  isLoading.value = true // Включаем индикатор загрузки
  try {
    const { data } = await supabase.from('users').select('*')
    users.value = data ?? [] // Сохраняем результат (или пустой массив)
  } catch (err) {
    error.value = 'Не удалось загрузить пользователей' // Сохраняем ошибку
  } finally {
    isLoading.value = false // Выключаем индикатор в любом случае
  }
}
```

### Объясняй неочевидное

```typescript
// Задержка 1 секунда — API имеет лимит 60 запросов в минуту
await sleep(1000)

// ВАЖНО: Supabase возвращает null если запись не найдена, а не ошибку
const { data } = await supabase.from('users').single()

// TODO: Добавить пагинацию когда будет больше 100 записей
```

### JSDoc для функций которые используются в разных местах

```typescript
/**
 * Форматирует дату в читаемый вид.
 * @param date — дата в формате ISO или объект Date
 * @returns строка вида "15 янв. 2024"
 * @example formatDate('2024-01-15') // '15 янв. 2024'
 */
export function formatDate(date: string | Date): string {
  // Реализация функции
}
```

---

## Чего избегать

| ❌ Не используй | ✅ Используй | Почему |
|-----------------|--------------|--------|
| `var` | `const` / `let` | var имеет проблемы с областью видимости |
| `==` | `===` | == делает неявное преобразование типов |
| `any` | Конкретный тип | Теряется смысл TypeScript |
| `// @ts-ignore` | Исправить тип | Скрывает реальные проблемы |
| `v-if` + `v-for` вместе | computed для фильтрации | Антипаттерн Vue, плохая производительность |
| Изменение props | `emit()` | Props только для чтения |
| Магические строки `'admin'` | Константы `USER_ROLE.ADMIN` | Легче искать и менять |
| `console.log` в проде | Удалять перед коммитом | Засоряет консоль браузера |

---

## Чеклист перед коммитом

- [ ] Нет закомментированного кода
- [ ] Нет `console.log` (кроме временной отладки)
- [ ] Нет `any` типов
- [ ] Все переменные и функции имеют понятные имена
- [ ] Есть комментарии на русском
- [ ] Функции делают одну вещь
- [ ] Нет дублирования кода
- [ ] ESLint без ошибок
